# Chap 7. 아키텍처 요소 테스트하기



### 테스트 피라미드

테스트 피라미드는 기본 전제로 만드는 비용이 적고, 유지보수하기 쉽고, 빨리 실행되고, 안정적인 작은 크기의 테스트들에 대해 높은 커버리지를 유지해야 한다는 것이다. 이 테스트는 하나의 단위가 제대로 동작하는지 확인할 수 있는 단위 테스트들이다.

**단위 테스트**는 피라미드의 토대에 해당하고 일반적으로 하나의 클래스를 인스턴스화하고 해당 클래스의 인터페이스를 통해 기능들을 테스트한다.

다음 계층인 **통합 테스트**는 연결된 여러 유닛을 인스턴스화하고 시작점이 되는 클래스의 인터페이스로 데이터를 보낸 후 유닛들의 넽트워크가 기대한대로 잘 동작하는지 검증한다.

마지막으로 **시스템 테스트**는 어플리케이션을 구성하는 모든 객체 네트워크를 가동시켜 특정 유스케이스가 전 계층에서 잘 동작하는지 검증한다.



### 단위 테스트로 도메인 엔티티 테스트하기

[예제코드](https://github.com/wikibook/clean-architecture/blob/main/src/test/java/io/reflectoring/buckpal/account/application/domain/AccountTest.java)

책의 예제 코드인 `AccountTest`이다.

이 테스트는 만들고 이해하는 것도 쉽고, 빠르게 실행된다. 이런 단위 테스트가 도메인 엔티티에 녹아 있는 비즈니스 규칙을 검증하기에 적절한 방법이다.



### 단위 테스트로 유스케이스 테스트하기

[예제코드](https://github.com/wikibook/clean-architecture/blob/main/src/test/java/io/reflectoring/buckpal/account/application/service/SendMoneyServiceTest.java)

책의 예제 코드인 `SendMoneyServiceTest`이다.

테스트 가독성을 위해 행동-주도 개발에서 사용되는 방식대로 given/when/then 으로 나뉘어있다.

여기에선 테스트 중인 서비스의 상태가 없기 때문에 특정 메소드와 상호작용했는지 여부를 검증하여 코드의 행동 변경 뿐만 아니라 구조 변경에도 취약해지기 때문에 어떠한 상호작용을 검증할지에 대해 신중히 생각해야 한다.

모든 동작을 검증하는 대신 중요한 핵심만 골라 집중해서 테스트하는 것이 좋다.



### 통합 테스트로 웹 어댑터 테스트하기

[예제코드](https://github.com/wikibook/clean-architecture/blob/main/src/test/java/io/reflectoring/buckpal/account/adapter/in/web/SendMoneyControllerTest.java)

책의 예제 코드인 `SendMondyController`코드이다.

`testSendMoney()`메소드에서 입력 객체를 만들어 HTTP 요청을 웹 컨트롤러에 보내고, 바디는 JSON형태로 포함된다. `isOK()`메소드로 HTTP 응답 상태를 검증하고, 웹 어댑터의 책임 대부분은 이 테스트에서 커버 가능하다고 볼 수 있다.

하지만 이것은 실제로 HTTP 프로토콜을 통해 테스트한 것은 아니고, MockMvc 객체를 이용해 모킹한 것이므로 프레임워크가 HTTP 프로토콜에 맞게 잘 변환했다고 믿어야한다.

이 테스트는 단위 테스트가 아니라 **통합 테스트**인데 그 이유는 하나의 웹 컨트롤러 테스트로 보이지만, `@WebMvcTest` 어노테이션으로 스프링이 특정 요청 경로, 자바와 JSON 간의 매핑, HTTP 입력 검증 등에 필요한 전체 객체 네트워크를 인스턴스화하도록 만든다.



### 통합 테스트로 영속성 어댑터 테스트하기

[예제코드](https://github.com/wikibook/clean-architecture/blob/main/src/test/java/io/reflectoring/buckpal/account/adapter/out/persistence/AccountPersistenceAdapterTest.java)

이 테스트에서는 데이터베이스를 모킹하지 않고 실제 데이터베이스에 접근한다. 데이터베이스를 모킹해서 테스트하더라도 같은 커버리지를 보여주지만 실제 데이터베이스를 연동했을 때 SQL 구문 오류나, 매핑 에러등의 문제가 추가적으로 생길 수 있다. 스프링에서 기본적으로 인메모리 데이터베이스를 테스트에서 사용하는데 이도 실제 데이터베이스를 연동하였을 때 문제가 생길 가능성이 있다.



### 시스템 테스트로 주요 경로 테스트하기

[예제코드](https://github.com/wikibook/clean-architecture/blob/main/src/test/java/io/reflectoring/buckpal/SendMoneySystemTest.java)

시스템 테스트에서는 전체 어플리케이션을 띄우고 API를 통해 요청을 보내고 모든 계층이 조화롭게 동작하는지 검증한다. 여기서는 웹 어댑터처럼 `MockMvc`에 요청을 보내는 것이 아니라 `TestRestTemplate`을 이요해서 요청을 보낸다. 다른 시스템과 통신해야하는 경우 모킹을 해야할 수 있다. 하지만 헥사고날 아키텍처는 몇 개의 출력 포트 인터페이스만 모킹하면 되어서 쉽게 해결 가능하다.

시스템 테스트는 여러 개의 유스케이스를 결합하여 시나리오를 만들 때 더 빛이 나는데, 시스템 테스트를 통해 중요한  시나리오들이 커버된다면 어플리케이션이 망가지지 않고 배포할 준비가 되었다고 볼 수 있다.



### 얼마만큼의 테스트가 충분할까?

라인 커버리지는 테스트 성공을 측정하는 데 있어서 잘못된 지표다. 라인 커버리지가 100%라 하더라도 버그가 잘 잡혔는지 확신할 수 없다.

각각의 프로덕션 버그에 대해서 **"테스트가 이 버그를 왜 잡지 못했을까?"를 생각하고 이에 대한 답변을 기록하고, 이 케이스를 커버할 수 있는 테스트를 추가해야 한다.** 시간이 지나면서 이러한 작업을 통해 배포가 편해지고, 개선되고 있음을 증명할 수 있다.

육각형 아키텍처에서 사용하는 전략이다.

- 도메인 엔티티를 구현할 때는 단위 테스트로 커버하자
- 유스케이스를 구현할 때는 단위 테스트로 커버하자
- 어댑터를 구현할 때는 통합 테스트로 커버하자
- 사용자가 취할 수 있늨 중요 애플리케이션 경로는 시스템 테스트로 커버하자

리팩터링할 때마다 테스트 코드도 변경해야 한다면 테스트는 테스트로서의 가치를 잃는다.



### 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

헥사고날 아키텍처는 도메인 로직과 바깥으로 향한 어댑터가 깔끔하게 분리되어있어 핵심 도메인 로직은 단위 테스트로, 어댑터는 통합 테스트로 처리하는 명확한 전락을 정의할 수 있다.



## Q&A

##### 테스트 중인 서비스의 상태가 없기 때문에 특정 메소드와 상호작용했는지 여부를 검증하여 코드의 행동 변경 뿐만 아니라 구조 변경에도 취약해지기 때문에 어떠한 상호작용을 검증할지에 대해 신중히 생각해야 한다. 의 의미는 무엇일까?

* https://www.testcontainers.org/quickstart/junit_5_quickstart/
* https://www.betterspecs.org/

* 모킹을 이용해서 마지막에 verify로 검증만 하기 때문에 실제 object가 바뀌었는지 확인은 불가능하다.



##### 세부 구현을 테스트 시나리오에 써두면 수정이 일어날 때마다 테스트코드가 변경이 일어나야한다.

* 단위 테스트에서는 그럴 수 밖에 없지 않을까? 세부 구현이라는게 해석하기에 따라 다른 느낌이다.
* http://www.yes24.com/Product/Goods/104084175



시스템 흐름 및 도메인 지식을 알게되면 테스트코드 작성에 도움이 된다.



##### 테스트코드를 짤 때 JUnit이외에 스폭 같은 프레임워크를 사용을 많이 쓰는지

코테스트로 많이 쓰고 있다.

* https://kotest.io/docs/framework/testing-styles.html
* nested를 이용한 계층형 테스트코드
  * https://johngrib.github.io/wiki/junit5-nested/

