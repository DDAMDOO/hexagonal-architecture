# Chap 9. 애플리케이션 조립하기

### 왜 조립까지 신경 써야 할까?

모든 의존성은 내부인 어플리케이션의 도메인 코드 방향으로 향해야 도메인코드가 바깥 계층의 변경으로부터 안전하다. 이러한 스타일은 테스트 편의성을 제공한다.

의존성 규칙을 어기지 않으면서 인스턴스를 생성할 책임을 지기 위해서는 아키텍처에 대해 중립적이고 인스턴스 생성을 위해 모든 클래스에 대한 의존성을 가지는 **설정 컴포넌트**가 있어야 한다. 설정 컴포넌트는 의존성 규칙에 정의된 대로 모든 내부 계층에 접근할 수 있는 원의 가장 바깥쪽에 위치한다.

#### 설정 컴포넌트의 수행 역할

- 웹 어댑터 인스턴스 생성
- HTTP 요청이 실제로 웹 어댑터로 전달되도록 보장
- 유스케이스 인스턴스 생성
- 웹 어댑터에 유스케이스 인스턴스 제공
- 영속성 어댑터 인스턴스 생성
- 유스케이스에 영속성 어댑터 인스턴스 제공
- 영속성 어댑터가 실제로 데이터베이스에 접근할 수 있도록 보장

설정 컴포넌트는 책임이 굉장히 많아 단일 책임 원칙을 위반하지만, 어플리케이션의 나머지 부분을 깔끔하게 유지하기 위해서 필요하다.



### 평범한 코드로 조립하기

의존성 주입 프레임워크의 도움 없이 코드를 만들면 웹 컨트롤러부터 영속성 어댑터까지 필요한 모든 클래스의 인스턴스로를 생성한 후 함께 연결하면 된다. 그리고 웹 컨트롤러를 HTTP로 노출하는 `startProcessingWebRequests()`를 호출한다. 이 방식이 가장 기본적인 어플리케이션 조립 방법이지만 단점이 존재한다.

1. 예시 코드에서는 웹 컨트롤러, 유스케이스, 영속성 어댑터가 하나씩만 존재하지만 규모가 커지게되면 코드의 량이 방대해진다.
2. 각 클래스에 속한 패키지 외부에서 인스턴스를 생성하기 때문에 public으로 선언되어야 한다. 그렇기 때문에 유스케이스가 영속성 어댑터에 직접 접근하는 것을 막을 수 엇ㅂ다.



### 스프링의 클래스패스 스캐닝으로 조립하기

스프링 프레임워크에서 어플리케이션을 조립한 결과물을 `어플리케이션 컨텍스트`라고 한다. 이는 어플리케이션을 구성하는 모든 객체를 포함한다.

클래스패스 스캐닝은 클래스패스에서 접근 가능한 모든 클래스를 확인해서 `@Component` 어노테이션이 붙은 클래스를 찾고, 각 클래스의 객체를 생성한다. 이 방식은 적절한 곳에 @Component 어노테이션을 붙이고 생성자만 잘 만들어주면 된다.

클래스패스 스캐닝 방식의 단점도 존재한다. 먼저 클래스에 프레임워크에 특화된 어노테이션을 붙여야 한다. 또한 프레임워크나 라이브러리 전문가가 아닌 이상 원인을 찾는 데 오랜 시간이 걸릴 수 있다.



### 스프링의 자바 컨피그로 조립하기

`@Configuration`어노테이션을 통해 클래스패스 스캐닝을 이용하긴 하지만 설정 클래스만 섵개하기 때문에 원인분석이 비교적 쉽다. 또한 이 방식에서는 `@Component` 어노테이션을 붙이지 않아도 되므로 프레임워크 의존성 없이 깔끔하게 유지할 수 있다.

이 방식도 단점이 존재하는데 설정 클래스가 생성하는 빈이 설정 클래스와 같은 패키지가 아닌 경우 이 빈들을 public으로 만들어야 한다.

