# Chap 1. 계층형 아키텍쳐의 문제는 무엇일까?

현재 우리가 사용하고 있는 일반적인 3계층 아키텍쳐는 아래와 같다.

<img src="Chap 1. 계층형 아키텍쳐의 문제는 무엇일까.assets/1651819435136.png" alt="1651819435136" style="zoom: 50%;" />

**웹**에서 요청을 받아 **도메인(비즈니스 계층)**의 서비스로 요청을 보내면 서비스에서는 필요한 비즈니스 로직을 수행하고, 도메인 엔티티를 조회하거나 변경하기 위해서 **영속성**계층의 컴포넌트를 호출한다.

잘 만들어진 계층형 아키텍쳐는 **선택의 폭을 넓히고**, 변화하는 요구사항과 외부요인에 **빠르게 적응**할 수 있다.

그렇다면 계층형 아키텍쳐의 문제점은 무엇일까.



### 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다.

웹 계층은 도메인 계층에 의존하고, 도메인 계층은 영속성 계층에 의존한다. 결국엔 모든 계층이 데이터베이스에 의존하게 된다. 그리고 우리가 만드는 대부분의 어플리케이션들은 **상태**도 중요한 요소이지만 대게는 **행동** 중심으로 모델링을 하게된다. 

전통적인 계층형 아키텍쳐에서는 이러한 이유로 DB구조를 먼저 생각하고, 도메인 로직을 구현하려고 한다. 하지만 도메인 로직을 먼저 만들어야 정확히 로직을 이해했는지 확인이 가능하기 때문에 맞지 않는 방식이다.

<img src="Chap 1. 계층형 아키텍쳐의 문제는 무엇일까.assets/1651820158993.png" alt="1651820158993" style="zoom:80%;" />

위 사진처럼 주로 ORM을 사용하게 되면 엔티티들이 일반적으로 영속성 계층에 있고, 계층은 하방으로만 접근 가능하기 때문에 도메인계층에서 엔티티에 접근이 가능하다. 하지만 이 경우 영속성 계층과 도메인 계층 사이에 **강한 결합**이 생겨 영속성 모델을 비즈니스 모델처럼 사용하게 된다. 이러한 경우 `즉시로딩/지연로딩`, `DB 트랜잭션`, `캐시 플러시`등 영속성과 관련된 작업이 필요하게 된다.



### 지름길을 택하기 쉬워진다.

계층형 아키텍처의 유일한 규칙은 **특정 계층에서는 같은 계층 또는 하위 계층에만 접근 가능 하다는 것**이다. 따라서 상위 계층에 접근하기 위해서는 해당 컴포넌트를 아래 계층으로 내려버린다. 이러한 작업이 계속되면 헬퍼 컴포넌트나 유틸리티 컴포넌트 등이 최하단 계층(영속성 계층)으로 내려갈 가능성이 커지고, 최하단 계층이 비대해진다.

이러한 이유로 추가적인 아키텍쳐 규칙을 정의하지 않는 이상 계층형 아키텍쳐는 최선의 구조가 아닐 수 있다.



### 테스트하기 어려워진다.

계층형 아키텍쳐에서 계층을 건너뛸 수 있다.(엔티티 필드를 하나만 조작하는 경우 이런식으로 사용할 때가 있다.) 이 방식은 두 가지 문제점을 가지고 있다.

* 단 하나의 필드를 조작하는 것에 불과하더라도 도메인 로직을 웹 계층에 구현하게 된다.
  * 유스케이스가 확장 되는 경우 도메인 로직들이 여기저기 생길 수 있다.
* 웹 계층 테스트에서 도메인 계층뿐만 아니라 영속성 계층도 모킹해야한다.
  * 테스트 난이도가 올라간다.



### 유스케이스를 숨긴다.

계층형 아키텍처에서 도메인 로직이 여러 계층에 흩어져있을 수 있다. 따라서 간단한 도메인 로직의 유스케이스가 생략되는 경우가 있을 수 있다. 또한 도메인 서비스의 너비에 대한 규약이 없기 때문에 넓은 서비스가 만들어지고, 이는 영속성 계층과 많은 의존성을 맺어 테스트하기 어렵고, 유스케이스가 커버하기 어려워진다.



### 동시 작업이 어려워진다.

계층형 아키텍처는 영속성 계층에 대한 개발이 선행된 이후 도메인 계층, 웹 계층이 만들어져야하기 때문에 동시 작업에 대해서 효율적이지 못하다.



### 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

어떠한 아키텍처를 사용하더라도 각 아키텍처의 함정을 염두해두고, 지름길을 택하지 않는다면 유지보수 하기 쉬운 솔루션을 만드는데 도움이 된다.