## Chap 2. 의존성 역전하기

#### 객체지향 설계의 5가지 원칙(SOLID)

##### SRP - 단일 책임 원칙(Single responsibility principle)

* 한 클래스는 하나의 책임만 가져야 한다.

##### OCP - 개방-폐쇄 원칙 (Open/closed principle)

* 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.

##### LSP - 리스코프 치환 원칙 (Liskov substitution principle)

* 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.

##### ISP - 인터페이스 분리 원칙 (Interface segregation principle)

* 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.

##### DIP - 의존관계 역전 원칙 (Dependency inversion principle)

* 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다.



2장에서는 객체지향 설계 5원칙 중 단일 책임 원칙과 의존성 역전 원칙에 대한 내용이다.



### 단일 책임 원칙

`하나의 컴포넌트는 오로지 한 가지 일만 해야 하고, 그것을 올바르게 수행해야 한다.`

위와 같은 정의를 가지고 있지만 오로지 한 가지 일을 해야 한다는 것 보다는 `변경되는 이유가 오직 하나뿐이어야 한다.`라고 하는게 조금 더 의미가 맞다.

<img src="Chap 2. 의존성 역전하기.assets/1651821477642.png" alt="1651821477642" style="zoom: 67%;" />

책에 나온 컴포넌트의 의존관계를 확인해보면 E를 변경할 이유는 E에 새로운 요구사항이 있을 때만 변경하지만, A의 경우 모든 컴포넌트에 의존하기에 다른 것들이 바뀌면 같이 변경되어야 한다.

이런식으로 단일 책임 원칙을 위반하게 되면 변경이 점점 어려워지고 시간과 비용이 증가한다.



### 부수효과에 관한 이야기

과거에 실패한 경험 때문에 개발자가 제시한 방안보다 시간과 비용이 많이 들더라도 기존의 방식을 고수하는 경우도 있다.



### 의존성 역전 원칙

계층형 아키텍쳐는 동일 계층 또는 하위 계층으로만 참조할 수 있기에 상위 계층들에 대한 변경사항이 더 많다. 그러한 이유로 영속성 계층 변경을 하기 위해서는 도메인 계층을 수정해야 하는데 이곳은 보통의 프로젝트에서 중요한 비즈니스 로직이 많아 수정하기 어렵다. 이럴 때 사용하는 것이 의존성 역전 원칙이다.

`코드상의 어떤 의존성이든 그 방향을 바꿀 수 있다.`라는 의존성 역전 원칙은 엔티티를 도메인 객체로 표현하고, 영속성 계층의 리포지토리가 도메인 계층에 엔티티에 의존하기 때문에 순환 의존성이 생긴다. 이를 도메인 계층에 리포티조리 인터페이스를 만들고, 구현체는 영속성 계층에 구현하도록 하여 사용하는 것이다.

<img src="Chap 2. 의존성 역전하기.assets/1651822058439.png" alt="1651822058439" style="zoom:67%;" />



### 클린 아키텍처

설계가 비즈니스 규칙의 테스트를 용이하게 하고, 비즈니스 규칙은 프레임워크, DB, UI 기술, 그 밖의 외부 어플리케이션이나 인터페이스로부터 독립적이다.

이 말은 도메인 코드가 바깥으로 향하는 의존성이 존재하면 안된다는 뜻이다. 대신 의존성 역전 원칙으로 만든 모든 의존성이 도메인 코드를 향하고 있다.

<img src="Chap 2. 의존성 역전하기.assets/1651823536158.png" alt="1651823536158" style="zoom:50%;" />

이 아키텍처에서 가장 중요한 것은 의존성 규칙이고, 의존성은 내부로 향해야 한다. 아키텍처의 코어에는 유스케이스에서 접근하는 도메인 엔티티들이 있고, 이것들은 단일 책임을 가지기 위해서 세분화되어있다. 이를 통해 넓이가 넓은 서비스가 되는 문제를 해결할 수 있다.

코어 주변으로는 비즈니스 규칙을 지원하는 다른 컴포넌트들이 있고, 바깥쪽 계층들은 다른 서드파티 컴포넌트에 접근할 수 있다. 

클린 아키텍처에서는 도메인 계층이 영속성 계층이나 외부 계층과 철저히 분리되야 하므로 엔티티에 대한 모델을 각 계층에서 유지보수 해야 한다.



### 육각형 아키텍처(헥사고날 아키텍처)

<img src="Chap 2. 의존성 역전하기.assets/1651823830417.png" alt="1651823830417" style="zoom:80%;" />

육각형 내부에서 도메인 엔티티와 상호작용하는 유스케이스가 있고, 의존성은 모두 코어로 향한다. 왼쪽 어댑터들은 **어플리케이션을 주도하는 어댑터**들이고, 우측에 있는 어댑터들은 **어플리케이션에 의해 주도되는 어댑터**이다.

주도하는 어댐터에서는 코어에 있는 유스케이스 클래스에 의해 구현되고 호출되는 인터페이스가 되고, 주도되는 어댑터는 어댑터에 의해 구현되고 코어에 의해 호출되는 인터페이스가 된다. 이러한 아키텍처 스타일을 `포트와 어댑터`라고도 한다.



### 유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까?

의존성을 역전시켜 도메인 코드가 다른 바깥쪽 코드에 의존하지 않게 함으로써 영속성과 UI에 특화된 문제들로부터 **도메인 로직의 결합을 제거**하고, **변경해야 하는 코드의 수를 줄일 수 있다.** 또한 도메인코드가 비즈니스 문제에 맞게 자유롭게 모델링 가능하고, 영속성 코드와 UI 코드도 영속성과 UI에 맞게 모델링 될 수 있다.



## Q&A

도메인이 다른 쪽에 의존하지 않아 테스트하기 좋아 유지보수에 도움이 된다.



#### 패키지 간의 순환 의존성에 대해서는 어떻게 인지할 수 있을 지.

package-private 접근 제어를 이용해서 일부분은 도움이 될 수 있다.



#### 넓은 서비스

기능에 특화된 서비스를 만드는것이 기존에 서비스에 메소드를 추가하는게 코스트가 낮기 때문에 서비스가 비대해지는 경향이 있다.

* 지속적인 피드백 및 코드 리뷰로 걸러야 하지만 쉬운 일은 아니다.
* 서비스를 나누는 기준을 잘 정립해야 하고, 기능 단위로 서비스를 나눌 수 있도록 해야 한다.
  * 이 부분에 대해서는 점진적으로 논의를 해야 함
  * 속해있는 조직들의 안목이 다 같이 향상되는 것이 좋다.



과연 1,000억을 버는 계층형 아키텍처가 좋을지 적자를 내는 헥사고날 아키텍처가 좋을지.