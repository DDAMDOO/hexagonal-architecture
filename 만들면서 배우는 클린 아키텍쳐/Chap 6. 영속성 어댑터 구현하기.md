# Chap 6. 영속성 어댑터 구현하기



### 의존성 역전

어플리케이션 서비스에서는 영속성 기능을 사용하기 위해 포트 인터페이스를 호출한다. 이 포트는 실제로 영속성 작업을 수행하고, DB와 통신할 책임을 가진 영속성 어댑터 클래스에 의해 구현된다.

헥사고날 아키텍처에서 영속성 어댑터는 `주도되는`, `아웃고잉`어댑터이다. 이는 호출될 뿐, 어플리케이션을 호출하지 않는다.



### 영속성 어댑터의 책임

#### 영속성 어댑터가 하는 일

1. ##### 입력을 받는다

2. ##### 입력을 DB 포맷으로 매핑한다

3. ##### 입력을 DB로 보낸다

4. ##### DB 출력을 어플리케이션 포맷으로 매핑한다

5. ##### 출력을 반환한다

영속성 어댑터는 포트 인터페이스를 통해 입력을 받는다. 입력 모델은 인터페이스가 지정한 도메인 엔티티 또는 특정 DB 연산 전용 객체이다.

영속성 어댑터는 DB를 쿼리하거나 변경하는데 사용할 수 있는 포맷으로 입력 모델에 매핑한다. 입력 모델을 평범한 SLQ 구문에 매핑해서 DB를 보내도 되고, 들어오는 데이터를 파일로 직렬화해서 그것으로부터 데이터를 읽어와도 된다. 핵심은 **영속성 어댑터의 입력 모델이 영속성 어댑터 내부에 있는 것이 아니라 어플리케이션 코어에 있기 대문에 영속성 어댑터 내부를 변경하는 것이 코어에 영향을 미치지 않는다는 것**이다.

그 후 영속성 어댑터는 DB에 쿼리를 날리고 쿼라 결과를 받아온다. 

마지막으로 DB 응답을 포트에 정의된 출력 모델로 매핑해서 반환한다.



### 포트 인터페이스 나누기

포트는 특정 엔티티가 필요로 하는 모든 DB 연산을 하나의 리포지토리 인터페이스에 넣는 것이 일반적이다. 그렇게 되면 DB 연산에 의존하는 각 서비스는 인터페이스에서 하나의 메소드만 사용하더라도 하나의 **넓은** 포트 인터페이스의 의존성을 가지게 된다.

이 방법은 `인터페이스 분리 원칙(Interface Segregation Principle, ISP)`로 해결할 수 있다. 이 원칙은 **클라이언트가 오로지 자신이 필요로 하는 메소드만 알면 되도록 넓은 인터페이스를 특화된 인터페이스로 분리해야 한다**라고 설명한다.

<img src="Chap 6. 영속성 어댑터 구현하기.assets/1652444786107.png" alt="1652444786107" style="zoom:67%;" />

<img src="Chap 6. 영속성 어댑터 구현하기.assets/1652444778643.png" alt="1652444778643" style="zoom:67%;" />

인터페이스 분리 원칙을 통해 아웃고잉 포트를 분리하게 되면 실제로 필요한 메소드에만 의존하기 때문에 테스트시에도 어떤 메소드를 모킹해야 할지 고민할 필요가 없다.

이렇게 좋은 포트를 만드는 것은 `플러그 앤 플레이`와 같이 서비스 코드를 짤 때 필요한 포트에 연결만 하면 된다.



### 영속성 어댑터 나누기

모든 영속성 포트를 구현하는 한, 하나 이상의 클래스 생성을 금지하는 규칙은 없다. 도메인 코드는 영속성 포트에 의해 정의된 명세를 어떤 클래스가 충족시키는지 관심이 없고, 모든 포트가 구현만 되어있으면 영속성 계층에서 하고 싶은 어떤 작업이든 해도 된다.

**애그리거트당 하나의 영속성 어댑터** 접근 방식은 여러 개의 바운디드 컨텍스트의 영속성 요구사항을 분리하기 위한 좋은 토대가 된다.

###### 	※ 애그리거트 : 불변식을 만족해서 하나의 단위로 취급될 수 있는 연관 객체의 모음



### 스프링 데이터 JPA 예제

코드에 대한 설명을 써둔 부분이다.

https://github.com/wikibook/clean-architecture 를 참고하자.



### 데이터베이스 트랜잭션은 어떻게 해야 할까?

트랜잭션은 하나의 특정한 유스케이스에 대해서 일어나는 모든 쓰기 작업에 걸쳐 있어야 한다. 그래야 그중 하나라도 실패할 경우 다 같이 롤백될 수 있기 때문이다.

영속성 어댑터는 어떤 데이터베이스 연산이 같은 유스케이스에 포함되는지 알지 못하기 때문에 언제 트랜잭션을 열고 닫을지 결정할 수 없다.

스프링에서 가장 간단한 방식은 `@Transactional` 어노테이션을 어플리케이션 서비스 클래스에 붙여서 모든 public 메소드들이 트랜잭션으로 감싸는 것이다.

서비스가 `@Transactional` 어노테이션으로 오염되지 않고 깔끔히 사용하고 싶다면 관점지향 프로그래밍으로 트랜잭션 경계를 코드에 위빙하면 된다.

###### 	※위빙 : 런타임이나 컴파일타임에 관점을 코드에 연결하는 것.



### 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

도메인 코드에 플러그인처럼 동작하는 영속성 어댑터를 만들면 도메인코드가 영속성과 관련된 것들로부터 분리되어 풍부한 도메인 모델을 만들 수 있다.